var searchIndex = {};
searchIndex["merkle"] = {"doc":"*merkle* implements a Merkle Tree in Rust.","items":[[3,"MerkleTree","merkle","The Merkle tree",null,null],[12,"height","","",0,null],[12,"count","","",0,null],[4,"Tree","","Binary Tree where leaves hold a stand-alone value.",null,null],[13,"Leaf","","",1,null],[12,"hash","merkle::Tree","",1,null],[12,"value","","",1,null],[13,"Node","merkle","",1,null],[12,"hash","merkle::Tree","",1,null],[12,"left","","",1,null],[12,"right","","",1,null],[11,"new","merkle","Create a new tree",1,{"inputs":[{"name":"vec"},{"name":"t"}],"output":{"name":"self"}}],[11,"get_hash","","Returns a hash from the tree.",1,null],[11,"make_leaf","","Create a new leaf",1,{"inputs":[{"name":"d"},{"name":"t"}],"output":{"name":"tree"}}],[11,"from_vec","","Constructs a Merkle Tree from a vector of data blocks.",0,{"inputs":[{"name":"d"},{"name":"vec"}],"output":{"name":"self"}}],[11,"root_hash","","Returns the tree&#39;s root hash.",0,null],[8,"Hashable","","By definition, data in the Merkle Tree must implement Hashable",null,null],[10,"to_bytes","","",2,null],[8,"MerkleDigest","","Extends the standard `crypto::digest::Digest` to play nicely with our Merkle Tree",null,null],[10,"hash_bytes","","",3,null],[10,"combine_hashes","","",3,null]],"paths":[[3,"MerkleTree"],[4,"Tree"],[8,"Hashable"],[8,"MerkleDigest"]]};
initSearch(searchIndex);
